resi_dat <- sapply(seq_along(rgp_in), function(x) read_resi(rgp_in[[x]]), USE.NAMES= TRUE, simplify = FALSE)
names(resi_dat) <- names(rgp_in)
# function to read residrill data in from .rgp files
read_resi <- function(x) {
#Extract drill data
drill <- x[grep("drill",x = x)]
drill <-gsub(pattern ='"|:|\\s|\\[|\\]|[[:alpha:]]|\\,$',replacement = "",x = drill,perl =TRUE)
drill <- as.double(unlist(strsplit(drill,split = ",")))
#extract feed data
feed <- x[grep("[[:punct:]]{1}feed[[:punct:]]{1}",x = x)]
feed <-gsub(pattern ='"|:|\\s|\\[|\\]|[[:alpha:]]|\\,$',replacement = "",x = feed,perl =TRUE)
feed <- as.double(unlist(strsplit(feed,split = ",")))
#get observation id
id <- x[grep("idNumber",x = x)]
id <-gsub(pattern = "idNumber|[[:punct:]]|\\s",replacement ="" ,x = id)
#resi number
number <- x[grep("[[:punct:]]{1}number[[:punct:]]{1}",x = x)]
number <-gsub(pattern = "[[:alpha:]]|[[:punct:]]|\\s",replacement ="" ,x = number)
#depth
depth_mm <- x[grep("depthMsmt",x = x)]
depth_mm <-gsub(pattern = "[[:alpha:]]|[[:punct:]]|\\s",replacement ="" ,x = depth_mm)
depth_mm <- as.double(depth_mm)
depth_mm <- 1:depth_mm
out <- data.frame(id, number, drill, feed, depth_mm)
return(out)
}
# function to find inflection points and generate knee_list
knee_f <- function(x){
xs <- x$obj$K
ys <- x$obj$U
dat <- data.frame(xs, ys)
dat <- dat[is.finite(rowSums(dat)),] ##get rid of inf values in r_list$obk
#print(dat)
knee <- uik(x = dat$xs, y= dat$ys)
return(knee)
}
# function for dynamic programming
dynProg.mean <- function(y, Kmax, Lmin) {
Nr  <- Kmax - 1
n <- length(y)
V <- matrix(Inf, nrow = n, ncol = n)
for (j1 in (1:(n-Lmin+1))){
for (j2 in ((j1+Lmin-1):n)) {
yj <- y[j1:j2]
nj <- j2-j1+1
V[j1,j2] <- sum(yj^2) - (sum(yj)^2)/nj
}
}
U <- vector(length=Kmax)
U[1] <- V[1,n]
D <- V[,n]
Pos <- matrix(nrow = n, ncol = Nr)
Pos[n,] <- rep(n,Nr)
tau.mat <- matrix(nrow = Nr,ncol = Nr)
for (k in 1:Nr){
for (j in 1:(n-1)){
dist <- V[j,j:(n-1)] + D[(j+1):n]
D[j] <- min(dist)
Pos[j,1] <- which.min(dist) + j
if (k > 1) { Pos[j,2:k] <- Pos[Pos[j,1],1:(k-1)] }
}
U[k+1] <- D[1]
tau.mat[k,1:k] <- Pos[1,1:k]-1
}
out <- list(Test=tau.mat, obj=data.frame(K=(1:Kmax),U=U))
return(out)
}
# function to output sound wood segment classification
get_sound <- function(df, r, Kopt, max_lenght=NULL) {
y <- df$feed
n <- length(y)
Topt <- c(0,r$Test[(Kopt-1),1:(Kopt-1)],n)
Tr <- c(0,Topt[2:Kopt],n)
dm <- data.frame()
for (k in (1:Kopt)) {
m <- median(y[(Topt[k]+1):Topt[k+1]],na.rm = TRUE)
sd <- mad(y[(Topt[k]+1):Topt[k+1]],na.rm = TRUE)
dm <- rbind(dm, c(Tr[k],Tr[k+1],m,sd))
}
names(dm) <- c("x1","x2","mu", "sd")
return(dm)
}
# function to calculate and remove bark from each trace
bark_f <- function(df) {
df$bark <- floor((unique(df$bark)*10)) # convert bark in mm to 1/10 of mm (like residrill data)
df$bark_far <-  df$bark+100 # added another cm to the bark on the far side of the tree as often resi would keep going before retracting
near <- df$bark[1] # mm on which first bark ends (entry point)
far <- df$bark_far[1] # mm on which second bark starts (exit point)
length <- length(df$bark)
if (df$abs_diff[1] <= 5) {
# for complete trace capturing entirety of tree dbh
out <- df[near:(length-far),]
} else{
# detect anomalies if resi did not come out the other end (incomplete trace)
out <- df[near:length,]
}
out$depth_mm_nb <- 1:nrow(out)
out
}
# function to split tree in half
tree2half <- function(x) {
# calculate radial distance
x$radial <- x$depth_mm_nb-unique((x$drill_dbh_cm*100)/2)
x$half <- ifelse(x$radial>0, yes = "upper",no = "lower")
# convert all values to positive to analyse
x$radial <- abs(x$radial)
# rearrange tables into radial distance (i.e. starting from center for both lower and upper halves)
x <- arrange(x,radial)
}
# function to fix traces < 90% coverage: splits tree in half, selects first half, and mirrors first half to recreate second half
fix_tree_half <- function(x) {
# calculate radial distance
x$radial <- x$depth_mm_nb-unique((x$drill_dbh_cm*100)/2)
x$half <- ifelse(x$radial>0, yes = "upper",no = "lower")
# remove 'upper' rows as this is an incomplete half
x <- x[!x$half == "upper",]
# duplicate lower half to mirror as replacement for incomplete upper half
y <- x
y$half[y$half == "lower"] <- "upper"
# flip upper df
y <- y[order(-y$radial),]
# remove radial = 0 (there can only be one and lower gets it)
y <- y[!y$radial == 0, ]
# fix numbering of resi_depth
recount <- max(x$depth_mm_nb)+1
end <- recount + nrow(y) - 1
y$depth_mm_nb <- recount:end
# rbind true first half (lower) and synthesized second half (upper)
df <- rbind(x, y)
# convert all values to positive to analyse
df$radial <- as.numeric(df$radial)
df$radial <- abs(df$radial)
return(df)
}
# function to get segments for sound wood classification
get_segment <- function(resi_dat, r, Kopt, alpha, sw) {
y <- resi_dat$feed
n <- length(y)
Topt <- c(0,r$Test[(Kopt-1),1:(Kopt-1)],n)
Tr <- c(0,Topt[2:Kopt],n)
dm <- data.frame()
for (k in (1:Kopt)) {
m <- median(y[(Topt[k]+1):Topt[k+1]],na.rm = TRUE)
sd <- mad(y[(Topt[k]+1):Topt[k+1]],na.rm = TRUE)
dm <- rbind(dm, c(Tr[k],Tr[k+1],m,sd))
}
names(dm) <- c("x1","x2","mu", "sd")
mean_feed <- sw$mu
sigma <- sw$sd
dm$pc_length <- (dm$x2-dm$x1)/last(dm$x2)
dm$z<- (dm$mu-mean_feed)/(sigma)
dm$p_val<- pnorm(dm$z,lower.tail = TRUE)
dm$sig <- ifelse(dm$p_val<= alpha, "*","")
dm$x1 <- n - dm$x1 # fix the problem of intervals not matching depth_mm_nb
dm$x2 <- n - dm$x2 # fix the problem of intervals not matching depth_mm_nb
#bark beggining is not significant
#dm$sig[1] <- "" take this out because bark has already been cut off
return(dm)
}
# function to get segments and classify damage on tree halves
half_tree_segment <- function(resi_dat, r, Kopt, alpha, feed_tree, sw) {
y <- resi_dat$feed
y_all <- feed_tree$feed
dbh_last <- unique(feed_tree$drill_dbh_cm)*100
dbh <- seq_along(1:dbh_last)
n <- length(y)
Topt <- c(0,r$Test[(Kopt-1),1:(Kopt-1)],n)
Tr <- c(0,Topt[2:Kopt],n)
dm <- data.frame()
for (k in (1:Kopt)) {
m <- median(y[(Topt[k]+1):Topt[k+1]],na.rm = TRUE)
sd <- mad(y[(Topt[k]+1):Topt[k+1]],na.rm = TRUE)
dm <- rbind(dm, c(Tr[k],Tr[k+1],m,sd))
}
names(dm) <- c("x1","x2","mu", "sd")
# area of semi circle
dm$area_sc <- (pi/2)*((dm$x2/2)^2)
# area of circle
# area of the doughnut
dm$doughtnut_area <- c(dm$area_sc[1],sapply(seq_len(Kopt-1), function(x)
dm$area_sc[x+1]-dm$area_sc[x]))
# proportion area compare to whole tree
dm$doughnut_pc_area <-(dm$doughtnut_area)/(pi*(length(y)/2)^2)
# mean_feed <- median(feed_all)
mean_feed <- sw$mu
# sigma <- mad(feed_all)
sigma <- sw$sd
dm$pc_length <- ((dm$x2-dm$x1)/length(y))*(length(y)/length(dbh))
dm$z<- (dm$mu-mean_feed)/(sigma)
dm$p_val<- pnorm(dm$z,lower.tail = TRUE)
dm$sig <- ifelse(dm$p_val<= alpha, "*","")
ifelse(resi_dat$half == "upper", dm$sig[length(dm$sig)] <- "", dm$sig[1] <- "") # sapwood correction, best solution
return(dm)
}
# function to fix traces to correct feed values = 0
fill_zeros <- function(x){
# define length of 50% tree diameter
half_length_mm <- as.numeric((x$drill_dbh_cm / 2 )*100)[1]
# find current length
length <- as.numeric(nrow(x))
# find how many rows have to be added
add <- half_length_mm - length
add <- c(1:add)
added <- data.frame(matrix(NA, ncol=ncol(x), nrow=length(add)))
colnames(added) <- colnames(x)
# rbind added to input
df <- rbind(x, added)
# if x$ feed is empty, then fill with 0
df$feed[is.na(df$feed)] <- 0
# adjust depth of trace
df$depth_mm <- c(1:half_length_mm)
# then fill out the rest of the columns til the end based on the last record
out <- df %>% fill(names(df))
return(out)
}
# read in residrill files (.rgp format)
files <- list.files("/Users/abbeyyatsko/Desktop/repos/residrill_MS/data/residrill_traces_rgp" ,full.names = TRUE, pattern = "rgp",recursive = TRUE)
# generate large list, each element is a residrill file
rgp_in <- sapply(files, readLines, USE.NAMES= TRUE, simplify = FALSE)
# make residrill files into data frames using the read_resi function, further formatting
resi_dat <- sapply(seq_along(rgp_in), function(x) read_resi(rgp_in[[x]]), USE.NAMES= TRUE, simplify = FALSE)
names(resi_dat) <- names(rgp_in)
resi_dat_l <- bind_rows(resi_dat)
resi_dat_l$number<- as.numeric(resi_dat_l$number)
library(tidyverse)
library(future.apply)
library(dplyr)
library(plyr)
library(tidyr)
library(stringr)
library(ggpubr)
library(ggplot2)
resi_dat_l <- bind_rows(resi_dat)
resi_dat_l$number<- as.numeric(resi_dat_l$number)
# read in drill metadata
dat <- read.csv("/Users/abbeyyatsko/Desktop/repos/stem_damage/R/resi_heights/data/residrill_OKtraces - residrill_OKtraces (1).csv")
View(resi_dat_l)
# read in drill metadata
dat <- read.csv("/Users/abbeyyatsko/Desktop/repos/residrill_MS/data/residrill_traces.csv")
# create column recording depth of residrill path
depth <- sapply(resi_dat, function(x) tail(x$depth_mm,1)/100,USE.NAMES = TRUE,simplify = FALSE)
names(depth) <- names(rgp_in)
# calculate depth that residrill went to for each trace
depth_v <- t(do.call(cbind.data.frame, depth))
id <- rownames(depth_v)
depth_df <- tibble(id, depth_v)
# extract trace ID from filename
depth_df$id <- qdapRegex::ex_between(depth_df$id, "renamed/", ".rgp")
# make sure drill IDs are factor variables
dat$drill_ID <- as.factor(dat$drill_ID)
depth_df <- as.data.frame(lapply(depth_df, unlist))
depth_df$id <- as.factor(depth_df$id)
# join resi path depth with metadata
d2 <-left_join(dat,depth_df, by = c("drill_ID"="id"))
# calculate difference between resi reading depth and dbh
d2$abs_diff <- (d2$drill_dbh_cm-d2$depth_v)
# calculate amount of bark based on Rosell
# https://nph.onlinelibrary.wiley.com/doi/10.1111/nph.13889
d2$bark <-d2$drill_dbh_cm^0.700
# d2 and resi_dat_l have IDs that are slightly different (PNW-01 / PNW01): from d2 remove '-' from drill_ID
d2$drill_ID <- gsub('-','',d2$drill_ID)
# separate out complete/complete traces based on percentage of trace measured based on field dbh
d2$perc_thru <- ((d2$depth_v / (d2$drill_dbh_cm )*100))
# table(d2$perc_thru > 90)
d2$full_trace <- ifelse(d2$perc_thru > 90, "Y", "N")
# remove 3 traces that have less than 50% coverage of full trace (these will have to be special cases)
d2$full_trace <- ifelse(d2$perc_thru < 50, yes = "R", no = d2$full_trace)
# classify complete and incomplete working dfs
complete <- d2[d2$full_trace == "Y",]
complete_join <- left_join(complete, resi_dat_l, by = c("drill_ID"="id"))
complete_join$drill_ID <- as.factor(complete_join$drill_ID)
# generate full list of complete traces
complete_join %>%
group_by(drill_ID, tree_ID, species) %>%
mutate(max_x = max(depth_v), max_y=max(feed),
sampled_stem = (depth_v*100)/drill_dbh_cm) %>%
ungroup() %>%
group_split(drill_ID, species, drill_dbh_cm) -> resi_dat_c
View(resi_dat_c)
save(resi_dat_c, file="/Users/abbeyyatsko/Desktop/repos/residrill_MS/R/Rdata/resi_dat_c.RData")
# calculate bark
resi_dat_c_nb <- lapply(seq_along(resi_dat_c), function(x) bark_f(resi_dat_c[[x]]))
# traces that are 50% < X < 90%
incomplete <- d2[d2$full_trace == "N",]
incomplete_join <- left_join(incomplete, resi_dat_l, by = c("drill_ID"="id"))
incomplete_join$drill_ID <- as.factor(incomplete_join$drill_ID)
# generate full list of incomplete traces
incomplete_join %>%
group_by(drill_ID, tree_ID, species) %>%
mutate(max_x = max(depth_v), max_y=max(feed),
sampled_stem = (depth_v*100)/drill_dbh_cm) %>%
ungroup() %>%
group_split(drill_ID, species, drill_dbh_cm) -> resi_dat_inc
# calculate bark
resi_dat_inc_nb <- lapply(seq_along(resi_dat_inc), function(x) bark_f(resi_dat_inc[[x]]))
# remove traces with <50% coverage from processing pipeline: deal with these seperately on a case-by-case
removed <- d2[d2$full_trace == "R",]
removed_join <- left_join(removed, resi_dat_l, by = c("drill_ID"="id"))
removed_join$drill_ID <- as.factor(removed_join$drill_ID)
removed_join %>%
group_by(drill_ID, tree_ID, species) %>%
mutate(max_x = max(depth_v), max_y=max(feed),
sampled_stem = (depth_v*100)/drill_dbh_cm) %>%
ungroup() %>%
group_split(drill_ID, species, drill_dbh_cm) -> resi_dat_rem
# see whats going on with these highly damaged ones
ggplot(resi_dat_rem[[2]], aes(x= depth_mm))+
ylab("Resistance")+
geom_area(aes(y = feed), fill = "black", alpha = 0.5)+
geom_area(aes(y = drill), fill ="green", alpha = 0.5)
library(tidyr)
library(dplyr)
library(stringr)
library(ggplot2)
library(smatr)
library(tidyverse)
library(ggpubr)
library(lme4)
library(easystats)
library(multcompView)
library(ggpmisc)
library(rcompanion)
# function to calculate trace average (combining upper and lower sections)
trace_means <- function(x){
area_avg <- aggregate(x$area, by=list(x$id), FUN=mean)
colnames(area_avg) <- c("id", "area_mean")
linear_avg <- aggregate(x$linear, by=list(x$id), FUN=mean)
colnames(linear_avg) <- c("id", "linear_mean")
out <- merge(area_avg, linear_avg, by = "id",
all.x = TRUE)
return(out)
}
# residrill process output data
df <- read.csv("/Users/abbeyyatsko/Desktop/repos/residrill_MS/R/data_out/damage_est_c.csv")
df <- df[c(2:4)]
# read in drill metadata from field
dat <- read.csv("/Users/abbeyyatsko/Desktop/residrill_MS/data/residrill_traces.csv")
# read in drill metadata from field
dat <- read.csv("/Users/abbeyyatsko/Desktop/repos/residrill_MS/data/residrill_traces.csv")
# residrill process output data
df <- read.csv("/Users/abbeyyatsko/Desktop/repos/residrill_MS/R/data_out/damage_est_c.csv")
df <- df[c(2:4)]
# split out tree ID to seperate column - extract trace ID from filename
df$id <- str_extract(df$resi_half, '\\b\\w+$')
# take average of upper and lower half to generate tree-level damage estimates
trace_avg <- trace_means(df)
# read in drill metadata from field
dat <- read.csv("/Users/abbeyyatsko/Desktop/repos/residrill_MS/data/residrill_traces.csv")
dat$id <- gsub('[^[:alnum:] ]','',dat$drill_ID)
# meta data for tree diameters
diameters <- read.csv("/Users/abbeyyatsko/Desktop/repos/residrill_MS/data/tree_metadata.csv")
# add site variable, append to tree ID (replicates of tree ID number need to be differentiated by site)
diameters$tree_site_ID <- paste(diameters$site, diameters$tree_ID, sep = "-")
diameters <- diameters[c("tree_site_ID", "dbh_cm")]
# join trace averages with metadata
merge <- left_join(trace_avg, dat, by = "id")
# note: 2 traces in 'dat' dropped (<50%, drill overload)
# add site variable, append to tree ID (replicates of tree ID number need to be differentiated by site)
merge$site <- sub("-.*", "", merge$drill_ID)
merge$tree_site_ID <- paste(merge$site, merge$tree_ID, sep = "-")
merge_resih <- left_join(merge, diameters, by = "tree_site_ID")
# explore differences in linear/area estimate of damage
ggplot(merge_resih, aes(drill_height_cm)) +
geom_smooth(aes(y = area_mean, colour = "area estimate"), method = lm, se=F) +
geom_smooth(aes(y = linear_mean, colour = "linear estimate"), method = lm, se=F) +
facet_wrap(~tree_site_ID)+
theme_classic()
# working with the linear estimate of damage. this is because symmetry of damage is an assumption used to fill in incomplete traces in processing steps
# subset out three myrtaceae species
myrt <- subset(merge_resih, species!="Larsenaikia ochreata" & species!="Gardenia?")
# define column for termite presence
myrt$termite_pres <- ifelse(myrt$mound == "Y" | myrt$runway == "Y" | myrt$termite == "Y", "Y", "N")
# add wood density (http://db.worldagroforestry.org/)
# Melaleuca stenostachya (genus) 0.7405
# Eucalyptus cullenii (species) 0.977
# Corymbia clarksoniana (genus) 0.8453
myrt$wd <- NA
myrt$wd <- ifelse(myrt$species == "Melaleuca stenostachya", 0.7405, myrt$wd)
myrt$wd <- ifelse(myrt$species == "Eucalyptus cullenii", 0.977, myrt$wd)
myrt$wd <- ifelse(myrt$species == "Corymbia clarksoniana", 0.8453, myrt$wd)
# export working df
# save(myrt, file="/Users/abbeyyatsko/Desktop/repos/stem_damage/R/resi_heights/myrt.RData")
# damage by species - drill height
plotNormalHistogram(sqrt(myrt$linear_mean))
ggplot(myrt, aes(x = drill_height_cm, y = sqrt(linear_mean))) +
geom_jitter() +
#facet_wrap(~tree_ID, scales = "free")+
scale_color_discrete(name="")+
scale_color_brewer("Blues")+
ylab("Proportion stem damage")+
xlab("Drill height (cm from tree base)")+
stat_poly_line()+
stat_poly_eq(formula = y ~ x, aes(label = paste(..eq.label.., ..rr.label.., ..p.value.label.., sep = "*`,`~")), parse = TRUE, label.x.npc = "left", vstep = 0.05)+
theme_classic()
# damage by species - drill diameter
ggplot(myrt, aes(x = drill_dbh_cm, y = linear_mean)) + # testing both linear_mean and area_mean
geom_smooth( method = lm, se=F) +
geom_jitter() +
facet_wrap(~species, scales = "free")+
#scale_color_brewer("Blues")+
stat_poly_line()+
stat_poly_eq(formula = y ~ x, aes(label = paste(..eq.label.., ..rr.label.., ..p.value.label.., sep = "*`,`~")), parse = TRUE, label.x.npc = "left", vstep = 0.05)+
theme_classic()+
theme(legend.position="none")
# boxplot of damage by tree species
aov.sp <- aov(linear_mean ~ species, data = myrt)
summary(aov.sp)
tukey <- TukeyHSD(aov.sp, conf.level=.95)
# compact letter display (for post hoc differences)
cld <- multcompLetters4(aov.sp, tukey)
ggplot(myrt, aes(x = species, y = linear_mean, color = species))+
geom_boxplot()+
geom_jitter()+
theme_classic()+
theme(legend.position="none")+
scale_x_discrete(limits = c("Corymbia clarksoniana", "Melaleuca stenostachya", "Eucalyptus cullenii"))+
geom_text(data=cld, aes(x=x, y=y, label=Letters), col='red', size=10)
# damage by wood density
ggplot(myrt, aes(x = wd, y = linear_mean))+
geom_point()+
theme_classic()
# need to make a different tree ID column with site included
myrt %>%
group_by(tree_site_ID, site) %>%
summarise(across(c("area_mean", "linear_mean", "dbh_cm", "wd"), mean)) -> myrt_treeavg
myrt_treeavg
# residrill area method and summed cookie damage
sma <- sma(myrt$area_mean ~ myrt$linear_mean)
summary(sma)
plot(sma)
# residuals
plot(sma, which = "residual")
abline(0, 0)
# need to make a different tree ID column with site included
myrt %>%
group_by(tree_site_ID, site) %>%
summarise(across(c("area_mean", "linear_mean", "dbh_cm", "wd"), mean)) -> myrt_treeavg
# residrill process output data
df <- read.csv("/Users/abbeyyatsko/Desktop/repos/residrill_MS/R/data_out/damage_est_c.csv")
df <- df[c(2:4)]
# split out tree ID to seperate column - extract trace ID from filename
df$id <- str_extract(df$resi_half, '\\b\\w+$')
# take average of upper and lower half to generate tree-level damage estimates
trace_avg <- trace_means(df)
# read in drill metadata from field
dat <- read.csv("/Users/abbeyyatsko/Desktop/repos/residrill_MS/data/residrill_traces.csv")
dat$id <- gsub('[^[:alnum:] ]','',dat$drill_ID)
# meta data for tree diameters
diameters <- read.csv("/Users/abbeyyatsko/Desktop/repos/residrill_MS/data/tree_metadata.csv")
# add site variable, append to tree ID (replicates of tree ID number need to be differentiated by site)
diameters$tree_site_ID <- paste(diameters$site, diameters$tree_ID, sep = "-")
diameters <- diameters[c("tree_site_ID", "dbh_cm")]
# join trace averages with metadata
merge <- left_join(trace_avg, dat, by = "id")
# note: 2 traces in 'dat' dropped (<50%, drill overload)
# add site variable, append to tree ID (replicates of tree ID number need to be differentiated by site)
merge$site <- sub("-.*", "", merge$drill_ID)
merge$tree_site_ID <- paste(merge$site, merge$tree_ID, sep = "-")
merge_resih <- left_join(merge, diameters, by = "tree_site_ID")
# explore differences in linear/area estimate of damage
ggplot(merge_resih, aes(drill_height_cm)) +
geom_smooth(aes(y = area_mean, colour = "area estimate"), method = lm, se=F) +
geom_smooth(aes(y = linear_mean, colour = "linear estimate"), method = lm, se=F) +
facet_wrap(~tree_site_ID)+
theme_classic()
# working with the linear estimate of damage. this is because symmetry of damage is an assumption used to fill in incomplete traces in processing steps
# subset out three myrtaceae species
myrt <- subset(merge_resih, species!="Larsenaikia ochreata" & species!="Gardenia?")
# define column for termite presence
myrt$termite_pres <- ifelse(myrt$mound == "Y" | myrt$runway == "Y" | myrt$termite == "Y", "Y", "N")
# add wood density (http://db.worldagroforestry.org/)
# Melaleuca stenostachya (genus) 0.7405
# Eucalyptus cullenii (species) 0.977
# Corymbia clarksoniana (genus) 0.8453
myrt$wd <- NA
myrt$wd <- ifelse(myrt$species == "Melaleuca stenostachya", 0.7405, myrt$wd)
myrt$wd <- ifelse(myrt$species == "Eucalyptus cullenii", 0.977, myrt$wd)
myrt$wd <- ifelse(myrt$species == "Corymbia clarksoniana", 0.8453, myrt$wd)
# export working df
# save(myrt, file="/Users/abbeyyatsko/Desktop/repos/residrill_MS/R/Rdata/myrt.RData")
# need to make a different tree ID column with site included
myrt %>%
group_by(tree_site_ID, site) %>%
summarise(across(c("area_mean", "linear_mean", "dbh_cm", "wd"), mean)) -> myrt_treeavg
load("~/Desktop/repos/residrill_MS/R/Rdata/tree_level_damage_myrt.RData")
View(tree_level_damage_myrt)
library(tidyr)
library(dplyr)
library(stringr)
library(ggplot2)
library(tidyverse)
library(ggpubr)
library(lme4)
library(easystats)
library(multcompView)
library(ggeffects)
library(nlme)
library(stats)
library(car)
library(ggpmisc)
library(glmmTMB)
library(patchwork)
load("/Users/abbeyyatsko/Desktop/repos/residrill_MS/R/Rdata/tree_level_damage_myrt.RData")
load("/Users/abbeyyatsko/Desktop/repos/residrill_MS/R/Rdata/myrt.RData")
# a. relationship between proportion damage and height in tree
glmmtb <- glmmTMB(linear_mean ~ drill_height_cm + dbh_cm.x + species + (1|tree_site_ID), myrt, family=list(family="beta",link="logit"))
summary(glmmtb)
check_model(glmmtb)
Anova(glmmtb)
prop <- ggpredict(glmmtb, terms = c("species"))
plot(prop)+
labs(x = "Species", y = "Damage", title = "Predicted proportion damage") # need to turn this into a finalized fig...
